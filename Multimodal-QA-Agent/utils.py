"""
Utility functions for the Multimodal QA Agent.
"""

import base64
import requests
from PIL import Image
from io import BytesIO
import mimetypes
from typing import Optional, Tuple

def encode_image_to_base64(image_path: str) -> str:
    """
    Encode an image file to base64 string.
    
    Args:
        image_path: Path to the image file
        
    Returns:
        Base64 encoded string of the image
    """
    with open(image_path, "rb") as image_file:
        return base64.b64encode(image_file.read()).decode('utf-8')

def download_image_from_url(url: str) -> Tuple[Image.Image, bytes]:
    """
    Download an image from a URL.
    
    Args:
        url: URL of the image
        
    Returns:
        Tuple of (PIL Image object, raw image bytes)
    """
    response = requests.get(url)
    response.raise_for_status()
    
    image_bytes = response.content
    image = Image.open(BytesIO(image_bytes))
    
    return image, image_bytes

def validate_image_format(image_bytes: bytes) -> bool:
    """
    Validate if the bytes represent a valid image.
    
    Args:
        image_bytes: Raw image bytes
        
    Returns:
        True if valid image, False otherwise
    """
    try:
        Image.open(BytesIO(image_bytes))
        return True
    except Exception:
        return False

def resize_image_if_needed(image: Image.Image, max_size: int = 1024) -> Image.Image:
    """
    Resize image if it's too large, maintaining aspect ratio.
    
    Args:
        image: PIL Image object
        max_size: Maximum dimension (width or height)
        
    Returns:
        Resized PIL Image object
    """
    width, height = image.size
    
    if width <= max_size and height <= max_size:
        return image
    
    # Calculate new dimensions maintaining aspect ratio
    if width > height:
        new_width = max_size
        new_height = int(height * (max_size / width))
    else:
        new_height = max_size
        new_width = int(width * (max_size / height))
    
    return image.resize((new_width, new_height), Image.Resampling.LANCZOS)

def get_image_info(image: Image.Image) -> dict:
    """
    Get information about an image.
    
    Args:
        image: PIL Image object
        
    Returns:
        Dictionary with image information
    """
    return {
        'format': image.format,
        'mode': image.mode,
        'size': image.size,
        'width': image.width,
        'height': image.height,
        'has_transparency': image.mode in ('RGBA', 'LA', 'P')
    }

def prepare_image_for_api(image_input) -> Tuple[str, dict]:
    """
    Prepare image for API consumption.
    
    Args:
        image_input: Either file path, URL, or PIL Image object
        
    Returns:
        Tuple of (base64 encoded image, image info)
    """
    if isinstance(image_input, str):
        if image_input.startswith(('http://', 'https://')):
            # URL
            image, image_bytes = download_image_from_url(image_input)
        else:
            # File path
            image = Image.open(image_input)
            with open(image_input, 'rb') as f:
                image_bytes = f.read()
    elif isinstance(image_input, Image.Image):
        # PIL Image object
        image = image_input
        buffer = BytesIO()
        image.save(buffer, format='JPEG')
        image_bytes = buffer.getvalue()
    else:
        raise ValueError("Invalid image input type")
    
    # Resize if needed
    image = resize_image_if_needed(image)
    
    # Convert to base64
    if isinstance(image_input, Image.Image):
        buffer = BytesIO()
        image.save(buffer, format='JPEG')
        image_bytes = buffer.getvalue()
    
    image_b64 = base64.b64encode(image_bytes).decode('utf-8')
    image_info = get_image_info(image)
    
    return image_b64, image_info

def format_response(response: str, include_metadata: bool = False) -> str:
    """
    Format the AI response for better presentation.
    
    Args:
        response: Raw response from the AI model
        include_metadata: Whether to include metadata in the response
        
    Returns:
        Formatted response string
    """
    # Basic formatting
    formatted = response.strip()
    
    # Add metadata if requested
    if include_metadata:
        formatted += "\n\n---\n*Response generated by Google Gemini Pro Vision*"
    
    return formatted

def log_interaction(question: str, response: str, model_used: str, 
                   success: bool, error: Optional[str] = None) -> dict:
    """
    Log an interaction for debugging and analysis.
    
    Args:
        question: The question asked
        response: The response received
        model_used: Which model was used
        success: Whether the interaction was successful
        error: Error message if any
        
    Returns:
        Dictionary with interaction details
    """
    from datetime import datetime
    
    return {
        'timestamp': datetime.now().isoformat(),
        'question': question,
        'response': response,
        'model_used': model_used,
        'success': success,
        'error': error,
        'response_length': len(response) if response else 0
    }
